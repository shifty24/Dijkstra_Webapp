const graphAsAdjacencyMatrix = [
	[0, 0, 1, 0],
	[0, 0, 1, 1],
	[1, 1, 0, 1],
	[0, 1, 1, 0],
];

const graphAsWeightedAdjacencyMatrix = [
	[0, 0, 1, 0],
	[0, 0, 3, 4],
	[1, 3, 0, 10],
	[0, 4, 10, 0],
];
/*Check nach 0 um zu überprüfen ob Edge besteht!
Die im potentiellen Loop aktuelle Node könnte als Parent gesetzt werden WENN Bedingungen zutreffen.
Jedes mal muss durch Array iteriert werden (Braucht viel Zeit).
(Jedoch fehlt unmittelbare Referenz, da im im Programm nur Array-Index hinterlegt ist und nicht die Nodebezeichner*/

const car = {
	type: "Fiat",
	model: "500",
	color: "white"
};

const graphAsNestedMap = {
	A: { C: 1 },
	B: { C: 3, D: 4 },
	C: { A: 1, B: 3, D: 10 },
	D: { B: 4, C: 10 },
};

function ShowHelloMessage() {
	var name = document.getElementById("user_name");
	document.getElementById("msg_welcome").innerHTML = "Welcome, " + user_name.value + "!";
}

function CheckNestedObject() {
	var nestedWeightValue = graphAsNestedMap.A.C;
	document.getElementById("node_check").innerHTML = "Entfernung von A zu C beträgt: " + nestedWeightValue + "!";
}

function CheckObjectEntries() {
	var objectEntries = Object.keys(graphAsNestedMap);
	document.getElementById("node_check").innerHTML = objectEntries;
}

function CheckValues() {
	document.getElementById("value_check").innerHTML = 
		distanceValues + "<br />" + parentNode + "<br />" + visited;

	let unorderedList = document.getElementById("arrayValues_check");
	var li;

	for (let i = 0; i < graphAsAdjacencyMatrix.length; i++) {
		li = document.createElement('li');
		li.innerText = graphAsWeightedAdjacencyMatrix[i];
		unorderedList.appendChild(li);
    }
}

//------------------------------Adjazenzmatrix- & Adjazenzlisteniterationstest------------------------------//

/*for(var i = 0; i < graphAsWeightedAdjacencyMatrix.length; i++) {
	for(var j = 0; j < graphAsAdjacencyMatrix[i].length; j++) {
		console.log(graphAsAdjacencyMatrix[i][j]);
	}
}

for (const property in graphAsNestedMap) {
	console.log(`${property}: ${graphAsNestedMap[property]}`);
}*/


//ALGO IMPLEMENTIERUNG TEST

function MinDistanceCheck(arr) {
	let minValue = Infinity;

	for (let i = 0; i < arr.length; ++i) {
		if (arr[i] < minValue) {
			minValue = i;
        }
	}
	return minValue;
}

var visited = [false, false, false, false];
var distanceValues = [Infinity, Infinity, Infinity, Infinity];
var parentNode = [null, null, null, null];
var currentDist;
var nodeWithMinDistance;

distanceValues[0] = 0;
parentNode[0] = -1;

for (let i = 0; i < graphAsWeightedAdjacencyMatrix.length; ++i) {
	nodeWithMinDistance = MinDistanceCheck(distanceValues);
	visited[nodeWithMinDistance] = true;
	//AN DIESER STELLE "TRUE" SETZEN, UM ZU VERMEIDEN, DASS NODE ÜBERPRÜFT WIRD VON DER MAN KOMMT.
	//if (visited[nodeWithMinDistance] == false) {
	// ERST UNTEN PRÜFEN, DA SONST IMMER NODE ÜBERPRÜFT WURDE, DIE GERADE "FALSE" GESETZT WIRD => IMMER "FALSE".	
		
		//for (let j = 0; j < graphAsWeightedAdjacencyMatrix[nodeWithMinDistance].length; ++j) {
		for (let j = 0; j < 4; ++j) {	
			console.log("Distancevalues: " + distanceValues);
			console.log("Parentnodes: " + parentNode);
			console.log("Visited: " + visited);
			if (graphAsWeightedAdjacencyMatrix[nodeWithMinDistance][j] != 0 && visited[j] == false) {
				currentDist = graphAsWeightedAdjacencyMatrix[nodeWithMinDistance][j];
			}
			if (currentDist + distanceValues[nodeWithMinDistance] < distanceValues[j]) {
				distanceValues[j] = currentDist + distanceValues[nodeWithMinDistance];
				parentNode[j] = nodeWithMinDistance;
            }
		}
    //}
}

document.getElementById("button_nameSubmit").onclick = ShowHelloMessage;
document.getElementById("button_nodeSubmit").onclick = CheckObjectEntries;
document.getElementById("button_valueChecker").onclick = CheckValues;